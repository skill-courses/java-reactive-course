# Poject Reactor Test

![project-reactor-test](../images/project-reactor-test.png)

前面的例子中，我们使用了`System.out.println()`的方式，通过屏幕输出来查看最终的结果，这种方式不仅低效，而且还需要将当前线程Sleep一下，非常不合理。由于本人是TDD的践行者，对这种通过打印输出来查看结果的方式很反感，今天我们就从测试的角度来聊聊，如何给响应式流写测试。

相比于传统的测试，响应式流的测试有些不同，主要的不同在于响应式流式异步的，只有被订阅者触发之后，才能产生数据。同时在整个过程中，还需要考虑`OnError`和`OnComplete`等的处理方式，所以不管是在写法上还是在理解上，对初学者来说都有些困难，想学习它的话，请做好心理准备。

估计Reactor官方也想到了这个问题，所以在Project Reactor Core中给我们提供了相关的依赖，你只需要引入他们即可：
```xml
<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-test</artifactId>
</dependency>
```

## StepVerify

`reactor-test`核心接口为StepVerifier，该接口提供了若干的静态工厂方法，从待测试的Publisher创建测试步骤。测试步骤被抽象为状态机接口FirstStep、Step和LastStep，分别代表了测试的初始阶段、中间阶段和最终阶段。这些Step上都具有一系列的expect和assert方法，用于测试当前状态是否符合预期。

![stepverify-steps](../images/stepverify-steps.jpg)

使用StepVerifier测试Publisher的套路如下：
1. 首先将已有的Publisher传入StepVerifier的`create`方法。
2. 多次调用`expectNext`、`expectNextMatches`方法设置断言，验证Publisher每一步产生的数据是否符合预期。
3. 调用`expectComplete`、`expectError`设置断言，验证Publisher是否满足正常结束或者异常结束的预期。
4. 调用`verify方`法启动测试。

例如：
```kotlin
@Test
fun test() {
    StepVerifier.create(Flux.just(1, 2, 3))
        .expectNext(1)// 依次验证数据是否符合预期
        .expectNext(2)
        .expectNext(3)
        .expectComplete() //验证Flux流是否正常关闭
        .verify() // 启动测试
}
```

### 对异常的断言
对于异常的处理，可以使用`expectError`来做断言处理！

```kotlin
@Test
fun test_error() {
    StepVerifier.create(Flux.just(1, 2, 3).handle<Int> { it, sink ->
        if(it == 2) {
            sink.error(RuntimeException())
            return@handle
        }
        sink.next(it)
    })
        .expectNext(1)// 依次验证数据是否符合预期
        .expectError(RuntimeException::class.java)
        .verify() // 启动测试
}
```

### 对元素特征的判断

之前的测试中，Publisher中数据的值都是确定的，所以可以使用expectNext进行判断，但是很多场景下，数据的值不完全确定，只知道数据的特征或者数据量太大，无法一一写出具体的值，此时`expectNextMatches`方法, 直接传入Predicate进行判断。`expectNextSequence` 这个方法接受一个集合，可以响应式流里面的每个元素生成的序列是否相等。

例如：
```kotlin
@Test
fun test_odd() {
    StepVerifier.create(Flux.range(0, 100).filter{it % 2 == 0})
        .expectNextMatches{it % 2 == 0}
        .expectNextCount(49)
        .verifyComplete();
    
    var odds = IntStream.range(0, 100).filter { it % 2 == 0 }.toList()
    StepVerifier.create(Flux.range(0, 100).filter { it % 2 == 0 })
        .expectNextSequence(odds)
        .expectComplete()
        .verify()
}
```